// Cartesia Voice Service - Sonic 3.0 Voice Library
// Updated with daughter-tested voices

// SONIC 3.0 VOICE LIBRARY - All IDs verified working
export const CARTESIA_VOICE_LIBRARY = {
  // NARRATORS
  'narrator_male_kyle': {
    id: 'c961b81c-a935-4c17-bfb3-ba2239de8c2f',
    name: 'Kyle',
    gender: 'male',
    style: 'narrator',
    description: 'Really good narrator voice',
    tags: ['narrator', 'storyteller', 'engaging'],
    preview_url: 'https://play.cartesia.ai/voices/c961b81c-a935-4c17-bfb3-ba2239de8c2f'
  },
  'narrator_male_rupert': {
    id: '0ad65e7f-006c-47cf-bd31-52279d487913',
    name: 'Rupert',
    gender: 'male',
    style: 'narrator',
    description: 'British narrator - Steve voice (daughter approved!)',
    tags: ['narrator', 'british', 'warm', 'character'],
    preview_url: 'https://play.cartesia.ai/voices/0ad65e7f-006c-47cf-bd31-52279d487913'
  },
  'narrator_female_marian': {
    id: '26403c37-80c1-4a1a-8692-540551ca2ae5',
    name: 'Marian',
    gender: 'female',
    style: 'narrator',
    description: 'Female narrator voice',
    tags: ['narrator', 'storyteller', 'warm'],
    preview_url: 'https://play.cartesia.ai/voices/26403c37-80c1-4a1a-8692-540551ca2ae5'
  },
  
  // MAIN CHARACTERS - FEMALE
  'main_female_maya': {
    id: 'cbaf8084-f009-4838-a096-07ee2e6612b1',
    name: 'Maya',
    gender: 'female',
    style: 'warm',
    description: 'Main character female voice',
    tags: ['protagonist', 'emotive', 'warm'],
    preview_url: 'https://play.cartesia.ai/voices/cbaf8084-f009-4838-a096-07ee2e6612b1'
  },
  'main_female_tessa': {
    id: '6ccbfb76-1fc6-48f7-b71d-91ac6298247b',
    name: 'Tessa',
    gender: 'female',
    style: 'warm',
    description: 'Main character female, good narrator too',
    tags: ['protagonist', 'versatile', 'emotive'],
    preview_url: 'https://play.cartesia.ai/voices/6ccbfb76-1fc6-48f7-b71d-91ac6298247b'
  },
  'young_female_daisy': {
    id: '32b3f3c5-7171-46aa-abe7-b598964aa793',
    name: 'Daisy',
    gender: 'female',
    style: 'youthful',
    description: 'Young female main character',
    tags: ['young', 'bright', 'cheerful'],
    preview_url: 'https://play.cartesia.ai/voices/32b3f3c5-7171-46aa-abe7-b598964aa793'
  },
  'young_female_dottie': {
    id: 'e3827ec5-697a-4b7c-9704-1a23041bbc51',
    name: 'Dottie',
    gender: 'female',
    style: 'youthful',
    description: 'Young female main character',
    tags: ['young', 'playful', 'energetic'],
    preview_url: 'https://play.cartesia.ai/voices/e3827ec5-697a-4b7c-9704-1a23041bbc51'
  },
  
  // MAIN CHARACTERS - MALE
  'main_male_gavin': {
    id: 'f4a3a8e4-694c-4c45-9ca0-27caf97901b5',
    name: 'Gavin',
    gender: 'male',
    style: 'friendly',
    description: 'Good for male character',
    tags: ['protagonist', 'emotive', 'friendly'],
    preview_url: 'https://play.cartesia.ai/voices/f4a3a8e4-694c-4c45-9ca0-27caf97901b5'
  },
  'main_male_zeke': {
    id: 'e00d0e4c-a5c8-443f-a8a3-473eb9a62355',
    name: 'Zeke',
    gender: 'male',
    style: 'narrator',
    description: 'American narrator/main character',
    tags: ['versatile', 'narrator', 'character'],
    preview_url: 'https://play.cartesia.ai/voices/e00d0e4c-a5c8-443f-a8a3-473eb9a62355'
  },
  'young_male_liam': {
    id: '41f3c367-e0a8-4a85-89e0-c27bae9c9b6d',
    name: 'Liam',
    gender: 'male',
    style: 'youthful',
    description: 'Good for male child - Aussie accent',
    tags: ['young', 'aussie', 'playful'],
    preview_url: 'https://play.cartesia.ai/voices/41f3c367-e0a8-4a85-89e0-c27bae9c9b6d'
  },
  
  // SPECIAL CHARACTERS
  'elder_male_griffin': {
    id: 'c99d36f3-5ffd-4253-803a-535c1bc9c306',
    name: 'Griffin',
    gender: 'male',
    style: 'mature',
    description: 'Older bit character on a quest',
    tags: ['elder', 'wise', 'character'],
    preview_url: 'https://play.cartesia.ai/voices/c99d36f3-5ffd-4253-803a-535c1bc9c306'
  },
  'special_female_kiara': {
    id: 'f8f5f1b2-f02d-4d8e-a40d-fd850a487b3d',
    name: 'Kiara',
    gender: 'female',
    style: 'character',
    description: 'Younger bit character - English with Indian accent',
    tags: ['character', 'indian', 'unique'],
    preview_url: 'https://play.cartesia.ai/voices/f8f5f1b2-f02d-4d8e-a40d-fd850a487b3d'
  },
  'special_neutral_thistle': {
    id: 'fb26447f-308b-471e-8b00-8e9f04284eb5',
    name: 'Thistle',
    gender: 'neutral',
    style: 'character',
    description: 'Younger bit character',
    tags: ['character', 'neutral', 'unique'],
    preview_url: 'https://play.cartesia.ai/voices/fb26447f-308b-471e-8b00-8e9f04284eb5'
  },
  'special_female_lulu': {
    id: 'e13cae5c-ec59-4f71-b0a6-266df3c9bb8e',
    name: 'Lulu',
    gender: 'female',
    style: 'character',
    description: 'Novelty bit character',
    tags: ['character', 'quirky', 'unique'],
    preview_url: 'https://play.cartesia.ai/voices/e13cae5c-ec59-4f71-b0a6-266df3c9bb8e'
  },
  'special_male_fran': {
    id: '79743797-2087-422f-8dc7-86f9efca85f1',
    name: 'Fran',
    gender: 'male',
    style: 'character',
    description: 'Novelty bit character - Spanish accent',
    tags: ['character', 'spanish', 'unique'],
    preview_url: 'https://play.cartesia.ai/voices/79743797-2087-422f-8dc7-86f9efca85f1'
  }
};

// Helper Functions
export function getAllVoices() {
  return Object.values(CARTESIA_VOICE_LIBRARY);
}

export function getVoicesByFilter(filter = {}) {
  const voices = getAllVoices();
  
  if (!filter || Object.keys(filter).length === 0) {
    return voices;
  }
  
  return voices.filter(voice => {
    if (filter.gender && voice.gender !== filter.gender) return false;
    if (filter.style && voice.style !== filter.style) return false;
    if (filter.tags && !filter.tags.some(tag => voice.tags.includes(tag))) return false;
    return true;
  });
}

export function getVoiceById(voiceId) {
  return getAllVoices().find(voice => voice.id === voiceId);
}

export function getVoiceName(voiceId) {
  const voice = getVoiceById(voiceId);
  return voice ? voice.name : 'Unknown Voice';
}

// Voice Assignment API Functions
export async function getVoiceAssignments(scriptId, userId) {
  try {
    // Query by script_id since that's what we have in the UI
    const response = await fetch(import.meta.env.VITE_N8N_GET_VOICE_ASSIGNMENTS_WEBHOOK, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        script_id: scriptId,
        user_id: userId
      })
    });

    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }

    // Check if response has content before parsing JSON
    const responseText = await response.text();
    console.log('üîç Get voice assignments raw response:', responseText);
    
    if (!responseText || responseText.trim() === '') {
      console.log('Empty response from voice assignments API, returning empty assignments');
      return {};
    }

    let result;
    try {
      result = JSON.parse(responseText);
      console.log('üîç Parsed get voice assignments result:', result);
    } catch (parseError) {
      console.error('Failed to parse JSON response:', parseError);
      console.error('Response text:', responseText);
      return {};
    }
    
    // Handle different response formats (similar to save response handling)
    const assignments = {};
    
    // Check for "object Object" key format with single data object
    if (result['object Object'] && result['object Object'].data) {
      const responseData = result['object Object'];
      
      // Handle single assignment object (get response)
      if (responseData.data.character_name && responseData.data.cartesia_voice_id) {
        console.log('üîç Using "object Object" single assignment format for get response');
        assignments[responseData.data.character_name] = responseData.data.cartesia_voice_id;
      }
      // Handle assignments array (save response)
      else if (responseData.data.assignments && Array.isArray(responseData.data.assignments)) {
        console.log('üîç Using "object Object" assignments array format for get response');
        responseData.data.assignments.forEach(assignment => {
          assignments[assignment.character_name] = assignment.cartesia_voice_id;
        });
      }
    }
    // Check for direct array format
    else if (result && Array.isArray(result)) {
      console.log('üîç Using direct array format for get response');
      result.forEach(assignment => {
        assignments[assignment.character_name] = assignment.cartesia_voice_id;
      });
    }
    // Check for data.assignments format
    else if (result.data && Array.isArray(result.data.assignments)) {
      console.log('üîç Using data.assignments format for get response');
      result.data.assignments.forEach(assignment => {
        assignments[assignment.character_name] = assignment.cartesia_voice_id;
      });
    }
    // Check for direct assignments array
    else if (result.assignments && Array.isArray(result.assignments)) {
      console.log('üîç Using assignments array format for get response');
      result.assignments.forEach(assignment => {
        assignments[assignment.character_name] = assignment.cartesia_voice_id;
      });
    }
    else {
      console.warn('üîç Unknown get voice assignments response format:', Object.keys(result));
    }
    
    console.log('üîç Final converted assignments:', assignments);
    
    return assignments;
  } catch (error) {
    console.error('Error getting voice assignments:', error);
    console.error('Full error details:', error.message);
    return {};
  }
}

export async function saveVoiceAssignments(scriptId, assignments, userId, productionId = null) {
  try {
    // Convert assignments to match your schema
    const formattedAssignments = Object.entries(assignments).map(([characterName, voiceId]) => ({
      script_id: scriptId,
      production_id: productionId, // Include production_id for RLS
      character_name: characterName,
      cartesia_voice_id: voiceId, // Using your schema field name
      voice_name: getVoiceById(voiceId)?.name || 'Unknown Voice',
      voice_settings: {},
      emotion_mappings: {},
      default_emotion: 'neutral'
    }));

    const payload = {
      script_id: scriptId,
      production_id: productionId,
      assignments: formattedAssignments,
      user_id: userId
    };
    
    console.log('üíæ Sending save request:', JSON.stringify(payload, null, 2));
    console.log('üì° Webhook URL:', import.meta.env.VITE_N8N_SAVE_VOICE_ASSIGNMENTS_WEBHOOK);

    const response = await fetch(import.meta.env.VITE_N8N_SAVE_VOICE_ASSIGNMENTS_WEBHOOK, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(payload)
    });

    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }

    // Check if response has content before parsing JSON
    const responseText = await response.text();
    console.log('Save response text:', responseText);
    
    if (!responseText) {
      console.log('Empty response from save webhook');
      return { success: true, message: 'Voice assignments saved successfully' };
    }
    
    const result = JSON.parse(responseText);
    console.log('Save response:', result);
    
    // Handle malformed response with "object Object" key
    if (result['object Object']) {
      console.log('Using object Object key for save response');
      return result['object Object'];
    }
    
    return result;
  } catch (error) {
    console.error('Error saving voice assignments:', error);
    console.error('Full error details:', error.message);
    throw error;
  }
}

export async function previewVoiceOnLine(voiceId, text, characterName, userId, scriptId) {
  try {
    const response = await fetch(import.meta.env.VITE_N8N_LINE_PREVIEW_WEBHOOK, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify({
        line_data: {
          text,
          speaker: characterName
        },
        voice_id: voiceId,
        user_id: userId,
        script_id: scriptId,
        line_id: 'preview-line'
      })
    });

    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }

    const result = await response.json();
    return result;
  } catch (error) {
    console.error('Error previewing voice:', error);
    return {
      success: false,
      error: error.message
    };
  }
}

export async function autoAssignVoices(scriptId, userId, characters = []) {
  try {
    console.log('üé≠ Auto-assign called with characters:', characters);
    
    const payload = {
      script_id: scriptId,
      user_id: userId,
      characters: characters
    };
    
    console.log('üîç Auto-assign payload being sent:', JSON.stringify(payload, null, 2));
    console.log('üîç Auto-assign webhook URL:', import.meta.env.VITE_N8N_AUTO_ASSIGN_VOICES_WEBHOOK);
    
    const response = await fetch(import.meta.env.VITE_N8N_AUTO_ASSIGN_VOICES_WEBHOOK, {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
      },
      body: JSON.stringify(payload)
    });

    if (!response.ok) {
      throw new Error(`HTTP error! status: ${response.status}`);
    }

    // Handle empty response like other functions
    const responseText = await response.text();
    console.log('üîç Auto-assign raw response:', responseText);
    
    if (!responseText || responseText.trim() === '') {
      console.log('Empty response from auto-assign API');
      return { success: false, error: 'Empty response from server' };
    }

    let result;
    try {
      result = JSON.parse(responseText);
      console.log('üîç Auto-assign parsed result:', result);
    } catch (parseError) {
      console.error('Failed to parse auto-assign JSON response:', parseError);
      console.error('Response text:', responseText);
      return { success: false, error: 'Invalid JSON response from server' };
    }
    
    return result;
  } catch (error) {
    console.error('Error auto-assigning voices:', error);
    return {
      success: false,
      error: error.message
    };
  }
}

